# SOLID

Акроним обозначающий пять принципов объектно-ориентированного программирования

## S - SRP - Single Responsibility Principle
###### Принцип единственной ответственности

Для каждого класса должно быть определено единственное назначение. Все ресурсы, необходимые для его осуществления, 
должны быть инкапсулированы в этот класс и подчинены только этой задаче.

Каждый класс должен определять единственный функционал, для того чтобы при изменении одного компонента другие продолжали
работать без изменений.

Следование принципу заключается обычно в декомпозиции сложных классов, которые делают сразу много вещей, на простые 
специализированные классы. Но также можно рассматривать и в объединении в отдельный класс однотипной функциональности, 
которая может оказаться распределённой по множеству классов.

Принцип служит для разделения типов поведения, благодаря которому ошибки, вызванные модификациями в одном поведении, 
не распространялись на прочие, не связанные с ним типы.

## O - OCP - Open-Closed Principle
###### Принцип открытости/закрытости

Программные сущности должны быть открыты для расширения, но закрыты для модификации. Эти сущности могут изменять свое
поведение без изменения исходного кода.

Следование принципу OCP заключается в том, что программное обеспечение изменяется не через изменение существующего кода, 
а через добавление нового кода. То есть созданный изначально код остаётся нетронутым и стабильным.
Новая реализация внедряется либо через наследование, либо через использование абстрактных интерфейсов 
и полиморфизма.

Принцип служит для того, чтобы делать поведение класса более разнообразным, не вмешиваясь в текущие операции, 
которые он выполняет. Благодаря этому вы избегаете ошибок в тех фрагментах кода, где задействован этот класс.

## L - LSP - Liskov Substitution Principle
###### Принцип подстановки Лисков

> Если П является подтипом Т, то любые объекты типа Т, присутствующие в программе, могут заменяться объектами типа П 
> без негативных последствий для функциональности программы.

>Функции, которые используют базовый тип, должны иметь возможность использовать подтипы базового типа не зная об этом

Следование принципу LSP заключается в том, что при построении иерархий наследования создаваемые наследники должны 
корректно реализовывать поведение базового типа. То есть если базовый тип реализует определённое поведение, то это 
поведение должно быть корректно реализовано и для всех его наследников.
Если у вас имеется класс и вы создаете на его базе другой класс, исходный класс становится родителем, а новый – его потомком. Класс-потомок должен производить такие же операции, как и класс-родитель. Это называется наследственностью.

Необходимо, чтобы класс-потомок был способен обрабатывать те же запросы, что и родитель, и выдавать тот же результат. 
Или же результат может отличаться, но при этом относиться к тому же типу.

Если класс-потомок не удовлетворяет этим требованиям, значит, он слишком сильно отличается от родителя и нарушает принцип.

Принцип служит для того, чтобы обеспечить постоянство: класс-родитель и класс-потомок могут использоваться одинаковым 
образом без нарушения работы программы.

## I - ISP - Interface Segregation Principle
###### Принцип разделения интерфейса

> Много интерфейсов, специально предназначенных для клиентов, лучше, чем один интерфейс общего назначения

Следование принципу ISP заключается в создании интерфейсов, которые достаточно специфичны и требуют только необходимый
минимум реализаций методов. Избыточные интерфейсы, напротив, могут требовать от реализующего класса создание большого 
количества методов, причём даже таких, которые не имеют смысла в контексте класса.

Класс должен производить только те операции, которые необходимы для осуществления его функций. Все другие действия 
следует либо удалить совсем, либо переместить, если есть вероятность, что они понадобятся другому классу в будущем.

Принцип служит для того, чтобы раздробить единый набор действий на ряд наборов поменьше – таким образом, каждый класс
делает то, что от него действительно требуется, и ничего больше.

## D - DIP - Dependency Inversion Principle
###### Принцип инверсии зависимостей 

> Зависимость на Абстракциях. Нет зависимости на что-то конкретное

Следование принципу инверсии зависимостей «заставляет» реализовывать высокоуровневые компоненты без встраивания 
зависимостей от конкретных низкоуровневых классов, что, например, сильно упрощает замену используемых зависимостей как 
по бизнес‑требованиям, так и для целей тестирования. При этом зависимость формируется не от конкретной реализации, а от 
абстракции — реализуемого зависимостью интерфейса.


Этот принцип служит для того, чтобы устранить зависимость классов верхнего уровня от классов нижнего уровня за счёт 
введения интерфейсов.